# ЛАБ 2
Лабораторная работа начинается с клонирования репозитория. Делаю аналогичные действия, что и в первый раз: использую команду git clone и вставляю ssh ссылку на свой репозиторий.
(рис.1)

![рис.1](https://github.com/a-orlova/lab1-orlova-a-a/blob/main/рис1.png)

Далее перемещаюсь в этот репозиторий с помощью команды cd и создаю внутри файл script.bash с помощью команды touch. Затем открываю файл для редактирования с помощью gedit и добавляю строку #!/bin/bash, то есть использую ту самую последовательность символов shebang, которая дает системе понять, что для выполнения команд внутри скрипта нужно использовать именно Bash-интерпретатор, который находится по указанному пути /bin/bash. 
Ниже строки shebang присваиваю значение переменной a, затем указываю условие проверки: если а не равно 23, то выводится соответствующее сообщение, иначе – прибавляется 19.
Проверяю работу скрипта – всё верно. (рис.2)

```bash
# объявляю переменную и придаю значение
a=$1

# делаю проверку по заданию
if [[ $a -eq 23 ]]
then    
    echo $(($a + 19))
else
    echo '$a is not "23"'
fi
```

![рис.2](https://github.com/a-orlova/lab1-orlova-a-a/blob/main/рис2.png)

Теперь выполняю задачу на разминку. Переписываю скрипт новым образом: на вход подается два числа, на выходе пользователь видит их сумму, разность и произведение. (рис.3) Скрипт выглядит так:
```bash
#!/bin/bash
# указываю переменные, присваивая им значения 
x=$1
y=$2

# вычисляю сумму, разность и произведение
sum=$(echo "$x + $y" | bc -l)
dif=$(echo "$x - $y" | bc -l)
prod=$(echo "$x * $y" | bc -l)

# вывод результата
echo "$sum $difference $product"
```

![рис.3](https://github.com/a-orlova/lab1-orlova-a-a/blob/main/рис3.png)

Я объявляю переменные x и y, присваивая им значения из аргументов скрипта ($1 и $2). Команду bc -l использую для вычислений с дробными числами и сохранения результата с точкой. Затем все результаты выводятся в одной строке, разделенные пробелами.

Теперь перехожу к основному заданию лабораторной. (рис.4)Ниже прикрепляю сам скрипт, а также значение и функцию каждой строки в нём.
```bash
#!/bin/bash

# функция, которая переводит из десятичной в 2-ную систему с доп. нулями до 8ми бит
dec_to_bin() {
    echo "obase=2; $1" | bc | awk '{printf "%08d", $0}'
}

# проверяю наличие самого аргумента (IP-адреса)
if [ -z "$1" ]; then
    echo "Использование: $0 <IPv4-адрес>"
    exit 1
fi

# разделяю IP-адрес на октеты
IFS='.' read -r -a octets <<< "$1"

# преобразую каждый октет в двоичный формат и объединяю их с точками
binary_ip=$(printf "%s.%s.%s.%s\n" \
    "$(dec_to_bin "${octets[0]}")" \
    "$(dec_to_bin "${octets[1]}")" \
    "$(dec_to_bin "${octets[2]}")" \
    "$(dec_to_bin "${octets[3]}")")

# вывод результата
echo "$binary_ip"
```

![рис.4](https://github.com/a-orlova/lab1-orlova-a-a/blob/main/рис4.png)

**1. #!/bin/bash** - это "shebang", такой же, как и в первом задании, указывает, какой интерпретатор следует использовать для выполнения скрипта, то есть bash

**2. dec_to_bin() { ... }** - эта строка определяет функцию dec_to_bin: она принимает на вход одно число в десятичном формате и преобразует его в двоичный, функция будет использоваться для перевода каждого октета IP-адреса

**3. echo "obase=2; $1" | bc | awk '{printf "%08d", $0}'** - строка внутри функции dec_to_bin, которая отвечает за преобразование числа в двоичный формат:
*	obase=2 устанавливает основание выходной системы счисления в 2, $1 — это переданный функции аргумент, то есть октет IP-адреса
*	bc — это утилита командной строки, которая выполняет арифметические операции, использую для преобразования числа из 10ной системы в 2ную
*	awk форматирует результат, "%08d" означает, что число будет дополнено нулями до длины 8 бит, если оно меньше
  
**4. if [ -z "$1" ]; then ... fi** – блок, проверяющий, передан ли аргумент:
*	-z "$1" проверяет, пустая ли строка в переменной $1, если да, то аргумент не был передан
*	then echo "Использование: $0 <IPv4-адрес>" - если аргумент не передан, выводится сообщение с инструкцией по использованию скрипта. 
*	exit 1 – завершает выполнение скрипта с кодом ошибки 1, то есть показывает, что возникла ошибка, что-то пошло не так
*	fi – завершаем блок if
  
**5. IFS='.' read -r -a octets <<< "$1"** - строка разделяет переданный IP-адрес на четыре части по точкам:
*	IFS='.'  установка разделителя на точку
*	read -r -a octets <<< "$1" - read читает строку из переменной переданного айпи-адреса и сохраняет части, т.е. октеты, в массив octets.
  
**6. binary_ip=$(printf "%s.%s.%s.%s\n" ... )** - строка отвечает за создание строки с двоичным представлением IP-адреса:
*	printf "%s.%s.%s.%s\n" – форматирую строку, объединяя четыре двоичных октета через точки
*	знако доллара перед скобкой подставляет результат команды в переменную binary_ip
*	"$(dec_to_bin "${octets[0]}")" и подобные вызывают для каждого октета функцию dec_to_bin, которая преобразует их в двоичный формат
  
**7. echo "$binary_ip"** – вывод результата

В итоге, скрипт принимает IP-адрес в десятичном формате, разбивает его на части, переводит каждую часть в двоичный формат и затем выводит результат. **Задание выполнено!**
